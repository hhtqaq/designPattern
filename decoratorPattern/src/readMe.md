#装饰者模式
## 介绍 ##
动态的给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。

一般来说装饰者模式有下面几个参与者：

- Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为

- ConcreteComponent：定义具体对象，即被装饰者
- Decorator：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类
- ConcreteDecorator：具体装饰者，用于扩展ConcreteComponent

**注：**
装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，这里利用继承是为了达到类型匹配，而不是利用继承获得行为。

利用继承设计子类，只能在编译时静态决定，并且所有子类都会继承相同的行为；利用组合的做法扩展对象，就可以在运行时动态的进行扩展。装饰者模式遵循开放-关闭原则：类应该对扩展开放，对修改关闭。利用装饰者，我们可以实现新的装饰者增加新的行为而不用修改现有代码，而如果单纯依赖继承，每当需要新行为时，还得修改现有的代码。

**总结：**

1. 装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被装饰者）的场合，都可以用装饰过得对象代替原始对象。
2.  可以用一个或多个装饰者包装一个对象（被装饰者）
3.  装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的
4.  被装饰者可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
5.  装饰者会导致出现很多小对象，如果过度使用，会让程序变得复杂。
